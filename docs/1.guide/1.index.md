---
icon: ph:book-open-duotone
---

# 入门指南

> 学习如何在您的项目中设置和使用 unstorage。

## 简介

我们通常根据使用案例选择一个或多个存储后端，例如文件系统、数据库或浏览器的 LocalStorage。当支持和组合多个选项或在它们之间切换时，将很快开始出现问题。对于 JavaScript 库作者来说，这通常意味着他们必须决定要支持多少个平台并为每个平台实现存储。

## 安装

安装 [`unstorage`](https://npmjs.com/package/unstorage) npm 包：

:pm-install{name="unstorage"}

## 使用

```js [my-storage.js]
import { createStorage } from "unstorage";

const storage = createStorage(/* opts */);

await storage.getItem("foo:bar"); // 或 storage.getItem('/foo/bar')
```

**选项：**

- `driver`：默认驱动程序，如果未提供，则使用 [memory](/drivers/memory)

## 接口

### `hasItem(key, opts?)`

检查存储中是否包含某个键。返回 `true` 或 `false`。

```js
await storage.hasItem("foo:bar");
```

您也可以使用 `has` 别名：

```js
await storage.has("foo:bar");
```

### `getItem(key, opts?)`

获取存储中某个键的值。返回一个 JavaScript 原始值或 `null`。

```js
await storage.getItem("foo:bar");
```

您也可以使用 `get` 别名：

```js
await storage.get("foo:bar");
```

### `getItems(items, opts)`

（实验性）并行获取存储中多个键的值。

数组中的每个项目可以是一个字符串或一个具有 `{ key, options? }` 格式的对象。

返回的值是一个 Promise，解析为一个对象数组，格式为 `{ key, value }`。

### `getItemRaw(key, opts?)`

**注意：** 这是一个实验性功能。请查看 [unjs/unstorage#142](https://github.com/unjs/unstorage/issues/142) 获取更多信息。

以原始格式获取存储中某个键的值。

```js
// 值可以是 Buffer、Array 或驱动程序的原始格式
const value = await storage.getItemRaw("foo:bar.bin");
```

### `setItem(key, value, opts?)`

向存储中添加/更新一个值。

如果值不是字符串，它将被转换为字符串。

如果值是 `undefined`，则等同于调用 `removeItem(key)`。

```js
await storage.setItem("foo:bar", "baz");
```

您也可以使用 `set` 别名：

```js
await storage.set("foo:bar", "baz");
```

### `setItems(items, opts)`

（实验性）并行添加/更新存储中的项目。

`items` 数组中的每个项目应该是 `{ key, value, options? }` 格式。

返回的值是一个 Promise，解析为一个对象数组，格式为 `{ key, value }`。

### `setItemRaw(key, value, opts?)`

**注意：** 这是一个实验性功能。请查看 [unjs/unstorage#142](https://github.com/unjs/unstorage/issues/142) 获取更多信息。

以原始格式向存储中添加/更新一个值。

如果值是 `undefined`，则等同于调用 `removeItem(key)`。

```js
await storage.setItemRaw("data/test.bin", new Uint8Array([1, 2, 3]));
```

### `removeItem(key, opts = { removeMeta = false })`

从存储中移除一个值（及其元数据）。

```js
await storage.removeItem("foo:bar", { removeMeta: true });
// 等同于 await storage.removeItem("foo:bar", true);
```

您也可以使用 `del` 或 `remove` 别名：

```js
await storage.remove("foo:bar");
await storage.del("foo:bar");
```

### `getMeta(key, opts = { nativeOnly? })`

获取特定键的元数据对象。

此数据来自两个来源：

- 驱动程序的原生元数据（如文件创建时间）
- 通过 `storage.setMeta` 设置的自定义元数据（覆盖驱动程序的原生元数据）

```js
await storage.getMeta("foo:bar"); // 对于 fs 驱动返回一个像 { mtime, atime, size } 的对象
```

### `setMeta(key, opts?)`

通过添加 `$` 后缀为特定键设置自定义元数据。

```js
await storage.setMeta("foo:bar", { flag: 1 });
// 等同于 storage.setItem('foo:bar$', { flag: 1 })
```

### `removeMeta(key, opts?)`

通过添加 `$` 后缀移除特定键的元数据。

```js
await storage.removeMeta("foo:bar");
// 等同于 storage.removeItem('foo:bar$')
```

### `getKeys(base?, opts?)`

获取所有键。返回一个字符串数组。

将过滤掉元数据键（以 `$` 结尾）。

如果提供了基准，则仅返回以基准开头的键，并且仅查询以基准开头的挂载。键仍具有完整路径。

```js
await storage.getKeys();
```

您也可以使用 `keys` 别名：

```js
await storage.keys();
```

### `clear(base?, opts?)`

移除所有存储的键/值。如果提供了基准，则仅清除与基准匹配的挂载。

```js
await storage.clear();
```

### `dispose()`

处理所有挂载的存储以确保没有留下打开的句柄。在退出进程之前调用它。

**注意：** 处理还清除了内存中的数据。

```js
await storage.dispose();
```

### `mount(mountpoint, driver)`

默认情况下，所有内容保存在内存中。我们可以以类 Unix 的方式挂载额外的存储空间。

当操作以挂载点开头的 `key` 时，将调用挂载的驱动程序，而不是默认存储。

除了 `base`，您可以设置 `readOnly` 和 `noClear` 以禁用写入和清除操作。

```js
import { createStorage } from "unstorage";
import fsDriver from "unstorage/drivers/fs";

// 创建一个具有默认内存存储的存储容器
const storage = createStorage({});

storage.mount("/output", fsDriver({ base: "./output" }));

// 写入到 ./output/test 文件
await storage.setItem("/output/test", "works");

// 向内存存储添加值
await storage.setItem("/foo", "bar");
```

### `unmount(mountpoint, dispose = true)`

注销一个挂载点。如果找不到挂载点或挂载点是根，则无效。

```js
await storage.unmount("/output");
```

### `watch(callback)`

开始监视所有挂载点。如果驱动程序不支持监视，仅在调用 `storage.*` 方法时发出事件。

```js
const unwatch = await storage.watch((event, key) => {});
// 停止此观察者
await unwatch();
```

### `unwatch()`

停止所有挂载点上的所有观察者。

```js
await storage.unwatch();
```

### `getMount(key)`

获取存储中特定键的挂载点（驱动程序和基准）。

```js
storage.mount("cache" /* ... */);
storage.mount("cache:routes" /* ... */);

storage.getMount("cache:routes:foo:bar");
// => { base: "cache:routes:", driver: "..." }
```

### `getMounts(base?, { parents: boolean }?)`

获取特定基准上的挂载点。

```js
storage.mount("cache" /* ... */);
storage.mount("cache:sub" /* ... */);

storage.getMounts("cache:sub");
// => [{ base: "cache:sub", driver }]

storage.getMounts("cache:");
// => [{ base: "cache:sub", driver }, { base: "cache:", driver }]

storage.getMounts("");
storage.getMounts("cache:sub", { parents: true });
// => [{ base: "cache:sub", driver }, { base: "cache:", driver }, { base: "", driver }]
```

## 泛型类型

**类型 `getItem` 返回值：**

```ts
await storage.getItem<string>("k"); // => <string>

await storage.getItemRaw<Buffer>("k"); // => <Buffer>
```

**类型检查 `setItem` 参数：**

```ts
storage.setItem<string>("k", "val"); // 检查通过
storage.setItemRaw<string>("k", "val"); // 检查通过

storage.setItem<string>("k", 123); // ts 错误
storage.setItemRaw<string>("k", 123); // ts 错误
```

**类型存储实例：**

```ts
const storage = createStorage<string>();

await storage.getItem("k"); // => <string>

storage.setItem("k", "val"); // 检查通过
storage.setItem("k", 123); // TS 错误
```

::note
前向引用使用继承而不是重写类型。
::

```ts
const storage = createStorage<string>();

storage.setItem<number>("k", 123); // TS 错误: <number> 不兼容 <string>
```

**使用 `prefixStorage` 指定子集类型：**

```ts
const storage = createStorage();

const htmlStorage = prefixStorage<string>(storage, "assets:html");

await htmlStorage.getItem("foo.html"); // => <string>

type Post = {
  title: string;
  content: string;
};

const postStorage = prefixStorage<Post>(storage, "assets:posts");

await postStorage.getItem("foo.json"); // => <Post>
```

在 [严格模式](https://www.typescriptlang.org/tsconfig#strict) 下，它还将返回 `null` 类型，以帮助您处理 `getItem` 缺失的情况。

```ts
"use strict";

await storage.getItem<string>("k"); // => <string | null>
```

**指定命名空间：**

```ts
type StorageDefinition = {
  items: {
    foo: string;
    baz: number;
  }
}

const storage = createStorage<StorageDefinition>();
await storage.has("foo"); // TS 会提示您有两个可选键："foo" 或 "baz"
await storage.getItem("baz"); // => string
await storage.setItem("foo", 12); // TS 错误: <number> 不兼容 <string>
await storage.setItem("foo", "val"); // 检查通过
await storage.remove("foo");